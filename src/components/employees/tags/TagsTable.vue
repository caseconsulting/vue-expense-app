<template>
  <v-form ref="form" v-model="valid" lazy-validation>
    <v-row class="mb-4">
      <v-col cols="6" class="pt-4">
        <!-- Create Tag -->
        <v-btn :disabled="creatingTag" @click="creatingTag = true" :size="isMobile ? 'small' : 'default'"
          >Create Tag <v-icon end>mdi-tag</v-icon></v-btn
        >
      </v-col>
      <v-col cols="6" class="pa-0 pa-md-2">
        <!-- Table Search Field -->
        <v-text-field
          variant="underlined"
          id="tagSearch"
          v-model="search"
          append-icon="search"
          label="Search"
          class="ma-0 pa-0"
          single-line
          hide-details
        ></v-text-field>
      </v-col>
    </v-row>
    <v-data-table v-if="loading" :headers="headers" :items="[]" loading></v-data-table>
    <v-data-table
      v-else
      :headers="headers"
      :items="tags"
      :search="search"
      :custom-filter="tableFilter"
      item-key="id"
      mobile-breakpoint="800"
    >
      <!-- Tag Name Slot -->
      <template v-slot:[`item.tagName`]="{ item }">
        <v-text-field
          variant="underlined"
          v-if="editedTag && item.id === editedTag.id"
          v-model="editedTag.tagName"
          :rules="[(v) => !!v || 'Field is required', duplicateTagName()]"
          :disabled="tagLoading"
          label="Tag Name*"
          single-line
          autofocus
        ></v-text-field>
        <span v-else>{{ item.tagName }} ({{ item.employees.length }})</span>
      </template>

      <!-- Employees Slot -->
      <template v-slot:[`item.employees`]="{ item }">
        <v-autocomplete
          v-if="editedTag && item.id === editedTag.id"
          auto-select-first
          v-model="editedTag.employees"
          :disabled="tagLoading"
          :items="filteredEmployees"
          :custom-filter="customFilter"
          multiple
          variant="underlined"
          chips
          clearable
          closable-chips
          :search="employeeSearch"
          @update:search="updateSearch"
          @update:model-value="employeeSearch = ''"
          label="Employees (optional)"
          item-title="employeeName"
          item-value="id"
        >
        </v-autocomplete>
        <span v-else v-for="(emp, i) in getTagEmployees(item.employees)" :key="i">
          <a @click="$router.push(`/employee/${emp.employeeNumber}`)">{{ nicknameAndLastName(emp) }}</a>
          <span v-if="i != item.employees.length - 1">, </span>
        </span>
      </template>

      <!-- Action Items Slot -->
      <template v-slot:[`item.actions`]="{ item }">
        <div v-if="editedTag && item.id === editedTag.id">
          <!-- Save Edited Tag -->
          <span>
            <v-tooltip activator="parent" text="Save" location="top"></v-tooltip>
            <v-btn
              :disabled="tagLoading || !valid"
              :loading="tagLoading"
              variant="text"
              icon
              @click="saveEditedTag"
              v-on="on"
            >
              <v-icon>mdi-content-save</v-icon>
            </v-btn>
          </span>
          <!-- Cancel Edited Tag -->
          <span>
            <v-tooltip activator="parent" text="Cancel" location="top"></v-tooltip>
            <v-btn :disabled="tagLoading" variant="text" icon @click="cancelEdit" v-on="on">
              <v-icon>mdi-cancel</v-icon>
            </v-btn>
          </span>
        </div>
        <div v-else>
          <!-- Edit Tag -->
          <span>
            <v-tooltip activator="parent" text="Edit" location="top" />
            <v-btn :disabled="!!editedTag || tagLoading" variant="text" icon @click="editTag(item)" v-on="on">
              <v-icon>mdi-pencil</v-icon>
            </v-btn>
          </span>
          <!-- Delete Tag -->
          <span>
            <v-tooltip activator="parent" text="Delete" location="top" />
            <v-btn
              :loading="tagLoading && !!deletedTag && deletedTag.id === item.id"
              :disabled="!!editedTag || tagLoading"
              variant="text"
              icon
              @click="deletedTag = item"
              v-on="on"
            >
              <v-icon>mdi-delete</v-icon>
            </v-btn>
          </span>
        </div>
      </template>
    </v-data-table>
    <!-- Confirmation Modals -->
    <delete-modal :toggleDeleteModal="!!deletedTag" type="tag"></delete-modal>
  </v-form>
</template>

<script>
import _ from 'lodash';
import api from '@/shared/api';
import { generateUUID, isMobile } from '@/utils/utils';
import { firstAndLastName, fullName, nicknameAndLastName } from '@/shared/employeeUtils';
import { getRequiredRules } from '@/shared/validationUtils';
import { updateStoreExpenseTypes, updateStoreTags } from '@/utils/storeUtils';

import DeleteModal from '@/components/modals/DeleteModal.vue';
import { AxiosError } from 'axios';

// |--------------------------------------------------|
// |                                                  |
// |                 LIFECYCLE HOOKS                  |
// |                                                  |
// |--------------------------------------------------|

/**
 * Created lifecycle hook
 */
async function created() {
  !this.$store.getters.tags ? await updateStoreTags() : _;
  this.tags = _.cloneDeep(this.$store.getters.tags);
  this.loading = false;
} // created

/**
 * Mounted lifecycle hook
 */
async function mounted() {
  this.emitter.on('canceled-delete-tag', () => (this.deletedTag = null));
  this.emitter.on('confirm-delete-tag', async () => {
    await this.deleteTag();
  });
} // mounted

/**
 * beforeDestroy lifecycle hook
 */
async function beforeDestroy() {
  this.emitter.off('canceled-delete-tag');
  this.emitter.off('confirm-delete-tag');
} // beforeDestroy

// |--------------------------------------------------|
// |                                                  |
// |                     METHODS                      |
// |                                                  |
// |--------------------------------------------------|

/**
 * Cancels the process of creating or editing a tag.
 */
function cancelEdit() {
  if (this.creatingTag) {
    this.tags.splice(0, 1);
    this.creatingTag = false;
  }
  this.editedTag = null;
} // cancelEdit

/**
 * Creates a tag.
 */
async function createTag() {
  this.editedTag.id = generateUUID();
  this.editedTag = await api.createItem(api.TAGS, this.editedTag);
  this.tags[0] = _.cloneDeep(this.editedTag);
  this.$store.dispatch('setTags', { tags: this.tags });
  this.editedTag = null;
  this.creatingTag = false;
} // createTag

/**
 * Custom filter for employee autocomplete options.
 *
 * @param _ - unused
 * @param queryText - text used for filtering
 * @param item - employee
 * @return string - filtered employee name
 */
function customFilter(_, queryText, item) {
  item = item.raw;

  const query = queryText ? queryText : '';
  const nickNameFullName = item.nickname ? `${item.nickname} ${item.lastName}` : '';
  const firstNameFullName = `${item.firstName} ${item.lastName}`;

  const queryNickName = nickNameFullName.toString().toLowerCase().indexOf(query.toString().toLowerCase());
  const queryFirstName = firstNameFullName.toString().toLowerCase().indexOf(query.toString().toLowerCase());

  if (queryNickName >= 0) return queryNickName;
  if (queryFirstName >= 0) return item.nickname ? true : queryFirstName;
  return false;
} // customFilter

/**
 * Deletes a tag.
 */
async function deleteTag() {
  try {
    this.tagLoading = true;
    let tag = _.cloneDeep(this.deletedTag);
    let response = await api.deleteItem(api.TAGS, tag.id);
    await updateStoreExpenseTypes();
    if (response instanceof AxiosError) {
      throw new Error(response.response.data.message);
    }
    let tagIndex = this.tags.findIndex((t) => t.id === tag.id);
    this.tags.splice(tagIndex, 1);
    this.$store.dispatch('setTags', { tags: this.tags });
    this.deletedTag = null;
    this.tagLoading = false;
    this.displaySuccess('Item was successfully deleted!');
  } catch (err) {
    this.displayError(err);
    this.deletedTag = null;
    this.tagLoading = false;
  }
} // deleteTag

/**
 * Displays error snackbar
 *
 * @param err error message to display
 */
function displayError(err) {
  let status = {
    statusType: 'ERROR',
    statusMessage: err,
    color: 'red'
  };

  this.emitter.emit('status-alert', status);
} // displayError

/**
 * Displays success message
 * @param msg success message to display
 */
function displaySuccess(msg) {
  let status = {
    statusType: 'SUCCESS',
    statusMessage: msg,
    color: 'green'
  };
  this.emitter.emit('status-alert', status);
} // displaySuccess

/**
 * Edits a tag.
 *
 * @param tag Object - The tag to edit
 */
function editTag(tag) {
  this.editedTag = _.cloneDeep(tag);
} // editTag

/**
 * Emits a message and data if it exists.
 *
 * @param msg - Message to emit
 * @param data - Data to emit
 */
function emit(msg, data) {
  if (data) {
    // data exists
    this.emitter.emit(msg, data);
  } else {
    // data does not exist
    this.emitter.emit(msg);
  }
} // emit

/**
 * Gets the full employee objects from a list of employee ids.
 *
 * @param employees Array - The list of employees on a tag
 */
function getTagEmployees(employees) {
  return _.map(employees, (e) => {
    return _.find(this.$store.getters.employees, (emp) => e === emp.id);
  });
} // getTagEmployees

/**
 * Either creates a tag or saves an edited tag that already exists.
 */
async function saveEditedTag() {
  this.valid = this.$refs.form.validate();
  if (this.valid) {
    try {
      this.tagLoading = true;
      if (_.isEmpty(this.editedTag.id)) {
        // Create new tag
        await this.createTag();
      } else {
        // Save existing tag
        let tagIndex = this.tags.findIndex((t) => t.id === this.editedTag.id);
        this.editedTag = await api.updateItem(api.TAGS, this.editedTag);
        this.tags[tagIndex] = _.cloneDeep(this.editedTag);
        this.tags = _.cloneDeep(this.tags);
        this.$store.dispatch('setTags', { tags: this.tags });
        this.editedTag = null;
      }
      this.tagLoading = false;
      this.displaySuccess('Item was successfully saved!');
    } catch (err) {
      this.displayError(err);
    }
  }
} // saveEditedTag

/**
 * Custom filter for searching in the tag table.
 *
 * @param __ - The value
 * @param search - The search value in the search bar
 * @param item - The item in the tag table
 * @returns Boolean - True if the item matches the search criteria
 */
function tableFilter(__, search, item) {
  item = item.raw;
  let found = false;
  let lcSearch = search.toLowerCase();
  if (item.tagName.toLowerCase().includes(lcSearch)) return true; // early exit if tag name matches search
  _.forEach(item.employees, (id) => {
    let e = _.find(this.$store.getters.employees, (emp) => emp.id === id);
    if (
      e &&
      (this.nicknameAndLastName(e).toLowerCase().includes(lcSearch) ||
        this.firstAndLastName(e).toLowerCase().includes(lcSearch) ||
        this.fullName(e).toLowerCase().includes(lcSearch))
    ) {
      found = true;
    }
  });
  return found;
} // tableFilter

/**
 * Updates the employee search with the autocomplete value.
 *
 * @param value String - The autocompletes value
 */
function updateSearch(value) {
  this.employeeSearch = value;
} // updateSearch

// |--------------------------------------------------|
// |                                                  |
// |                     COMPUTED                     |
// |                                                  |
// |--------------------------------------------------|

/**
 * Gets the active list of employees.
 */
function filteredEmployees() {
  let employees = _.filter(this.$store.getters.employees, (e) => {
    return e.workStatus > 0;
  });
  return _.map(employees, (e) => {
    return {
      ...e,
      employeeName: nicknameAndLastName(e)
    };
  });
} // filterdEmployees

// |--------------------------------------------------|
// |                                                  |
// |                     WATCHERS                     |
// |                                                  |
// |--------------------------------------------------|

/**
 * Watcher for when a tag is to be created.
 */
function watchCreatingTag() {
  if (this.creatingTag) {
    let tag = { id: '', tagName: '', employees: [] };
    this.tags.unshift(tag);
    this.editedTag = tag;
  }
} // watchCreatingTag

// |--------------------------------------------------|
// |                                                  |
// |                      EXPORT                      |
// |                                                  |
// |--------------------------------------------------|

export default {
  beforeDestroy,
  components: {
    DeleteModal
  },
  created,
  computed: {
    isMobile,
    filteredEmployees
  },
  data() {
    return {
      creatingTag: false,
      deletedTag: null,
      editedTag: null,
      employeeSearch: '',
      headers: [
        {
          title: 'Tag Name',
          key: 'tagName',
          width: '25%'
        },
        {
          title: 'Employees',
          key: 'employees',
          sortable: false,
          width: '60%'
        },
        {
          title: 'Actions',
          key: 'actions',
          sortable: false,
          align: 'center',
          width: '15%'
        }
      ],
      loading: true,
      tagLoading: false,
      tags: null,
      search: null,
      valid: true,
      duplicateTagName: () => {
        let arr = _.filter(this.tags, (t) => t.tagName === this.editedTag.tagName);
        return arr.length < 2 || 'Duplicate tag name';
      }
    };
  },
  methods: {
    cancelEdit,
    createTag,
    customFilter,
    deleteTag,
    displayError,
    displaySuccess,
    editTag,
    emit,
    firstAndLastName,
    fullName,
    getRequiredRules,
    getTagEmployees,
    nicknameAndLastName,
    saveEditedTag,
    tableFilter,
    updateSearch
  },
  mounted,
  watch: {
    creatingTag: watchCreatingTag
  }
};
</script>

<style scoped>
a {
  color: #1e79d3;
}
</style>
